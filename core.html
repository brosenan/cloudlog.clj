
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>cloudlog.core - Rule semantics</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item active" href="core.html">core</a><a class="sidebar-nav-item" href="interset.html">interset</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <span>cloudlog.core</span>
            <small>Rule semantics</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan&nbsp;&nbsp;<a href="mailto:brosenan@gmail.com">(brosenan@gmail.com)</a></h5>
              <h5>Date: 05 February 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/cloudlog.clj">https://github.com/brosenan/cloudlog.clj</a></h5>
              <h5>Version: 0.1.0-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#defrule-rule-definition-macro"><h4>1 &nbsp; defrule: Rule Definition Macro</h4></a><a class="section" data-scroll="" href="#simple-rules"><h5><i>1.1 &nbsp; Simple Rules</i></h5></a><a class="section" data-scroll="" href="#guards"><h5><i>1.2 &nbsp; Guards</i></h5></a><a class="section" data-scroll="" href="#joins"><h5><i>1.3 &nbsp; Joins</i></h5></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#defrule-rule-definition-macro"><h4>1 &nbsp; defrule: Rule Definition Macro</h4></a><a class="section" data-scroll="" href="#simple-rules"><h5><i>1.1 &nbsp; Simple Rules</i></h5></a><a class="section" data-scroll="" href="#guards"><h5><i>1.2 &nbsp; Guards</i></h5></a><a class="section" data-scroll="" href="#joins"><h5><i>1.3 &nbsp; Joins</i></h5></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="defrule-rule-definition-macro"></span><h2><b>1 &nbsp;&nbsp; defrule: Rule Definition Macro</b></h2></div><div><p>Definition:</p></div><div class="code"><a id="source-of-icloudlog-core--defrule--i"></a><pre><code class="clojure">(defmacro defrule [rulename args source-fact &amp; body]
  (let [conds (concat body [`[~(keyword (str *ns*) (name rulename)) ~@args]])
        [func meta] (generate-rule-func source-fact conds #{})]
    `(def ~rulename (with-meta ~func ~meta))))</code></pre></div><div><span id="simple-rules"></span><h3>1.1 &nbsp;&nbsp; Simple Rules</h3></div><div><p><code>defrule</code> defines a Cloudlog rule.  Such a rule always starts with a <strong>fact pattern</strong>:  a vector for which the first element is a keyword representing the fact name, and the rest of the elements are <strong>bindings</strong>, as we explain later.</p><p>The following rule &ndash; <code>foo-yx</code>, matches facts of the form <code>&#91;:test/foo x y&#93;</code> (facts named <code>:test/foo</code> with two arguments we call <code>x</code> and <code>y</code>), and for each such fact it creates a new fact of the form <code>&#91;foo-yz y x&#93;</code>.</p></div><div class="code"><pre><code class="clojure">(defrule foo-yx [y x]
     [:test/foo x y])</code></pre></div><div><p>What <code>defrule</code> actually does is define a Clojure function that, when given the arguments for the source fact (in our case, <code>:test/foo</code>), it returns a sequence of bindings for the target fact (<code>foo-yx</code>).</p></div><div class="code"><pre><code class="clojure">(foo-yx [1 2]) =&gt; [[2 1]]</code></pre></div><div><p>The function contains metadata regarding the identity of the source fact.</p></div><div class="code"><pre><code class="clojure">(:source-fact (meta foo-yx)) =&gt; [:test/foo 2]</code></pre></div><div><p>The arity of the target fact (the number of elements in each vector in the result) is also metadata of the function.</p></div><div class="code"><pre><code class="clojure">(:target-arity (meta foo-yx)) =&gt; 2</code></pre></div><div><p>The arguments of both the rule and the source fact are not limited to being variables. They can also be <strong>values</strong>.</p><p>When a fact is introduced to a rule, it is <a href='https://en.wikipedia.org/wiki/Unification_%28computer_science%29'>unified</a>  with source-fact part of the rule's body.  Variables in the source-fact are bound to the corresponding values in the input fact, and values are compared.  If the values differ, the rule is not applied to this fact.</p><p>For example, the following rule is similar to <code>foo-yx</code>, only that it assumes that <code>x == 1</code>.</p></div><div class="code"><pre><code class="clojure">(defrule foo-unify [x 1]
  [:test/foo 1 x])</code></pre></div><div><p>For <code>&#91;1 2&#93;</code>, we will get the same result as before:</p></div><div class="code"><pre><code class="clojure">(foo-unify [1 2]) =&gt; [[2 1]]</code></pre></div><div><p>But if we introduce a fact in which <code>x != 1</code>, the rule will not be applied, and the result sequence will be empty.</p></div><div class="code"><pre><code class="clojure">(foo-unify [2 3]) =&gt; empty?</code></pre></div><div><span id="guards"></span><h3>1.2 &nbsp;&nbsp; Guards</h3></div><div><p>While simple rules are useful in some cases, they are limited to reordering or restructuring the fields in the source fact,  but cannot do more.  <strong>Guards</strong> fix this by allowing (purely-functional) Clojure functions to be used inside rules.</p><p>Guards are Clojure forms such as <code>let</code>, <code>for</code> or <code>when</code>.  The example below uses <code>let</code> to create a new binding (variable <code>z</code>), calculated as the sum of <code>x</code> and <code>y</code>:</p></div><div class="code"><pre><code class="clojure">(defrule foo-let [z]
     [:test/foo x y]
     (let [z (+ x y)]))</code></pre></div><div><p>The result is as you would expect.</p></div><div class="code"><pre><code class="clojure">(foo-let [1 2]) =&gt; [[3]]</code></pre></div><div><p>Below is a more elaborate example.  Here we index text documents by:</p><ol><li>Extracting all the words from a document, and iterating over them using a <code>for</code> guard</li><li>Converting each word to lower-case (so that indexing becomes case-insensitive) using a <code>let</code> guard, and</li><li>Filterring out "stopwords", using a <code>when-not</code> guard</li></ol></div><div class="code"><pre><code class="clojure">(def stop-words #{&quot;a&quot; &quot;is&quot; &quot;to&quot; &quot;the&quot;})
(defrule index-docs [word id]
     [:test/doc id text]
     (for [word (clojure.string/split text #&quot;[,!.? ]+&quot;)])
     (let [word (clojure.string/lower-case word)])
     (when-not (contains? stop-words word)))</code></pre></div><div><p>Now, if we index a document, we will get index entries with the words it contains, lower-case, excluding stopwords.</p></div><div class="code"><pre><code class="clojure">(index-docs [1234 &quot;Hello, to the  worlD!&quot;]) =&gt; [[&quot;hello&quot; 1234] [&quot;world&quot; 1234]]</code></pre></div><div><p>Cloudlog guards differ from the corresponding Clojure forms in that they do not have a body. In the above code, the <code>for</code> form ends after the bindings have been established, and the same goes for the <code>let</code> and <code>when-not</code> forms.  A corresponding Clojure implementation could look like this:</p></div><div class="code"><pre><code class="clojure">(for [word (clojure.string/split text #&quot;[,!.? ]+&quot;)]
  (let [word (clojure.string/lower-case word)]
    (when-not (contains? stop-words word)
      (emit some result))))</code></pre></div><div><p>with each form <em>containing</em> the following forms.  However, Cloudlog is a logic programming language, like Prolog or core.logic.  Cloudlog guards are just like predicates.  Bindings in <code>let</code> and <code>for</code> forms assert a certain relationship between the bound variable and the expression to its right. A <code>when</code> or <code>when-not</code> guards are just like predicates that pass or fail depending on the  (Clojure-level) predicate given to them.</p></div><div><span id="joins"></span><h3>1.3 &nbsp;&nbsp; Joins</h3></div><div><p>Even with guards, rules are still limited to considering only a single fact. Sometimes we need to draw a conclusion based on a combination of facts. A classical example is applications such as <a href='https://twitter.com'>Twitter</a>, in which users can:</p><ol><li>Follow other users,</li><li>Post tweets,</li><li>View their <strong>timelines</strong>, consisting of all the tweets made by users they follow.</li></ol><p>To successfully generate a timeline, a rule needs to take into consideration both who follows whom, and tweets &ndash; two different kinds of facts.  Moreover, there is a data dependency between the two.  We are only interested in tweets made by users we follow.</p><p>Cloudlog rules can depend on more than just the source-fact.</p></div><div class="code"><pre><code class="clojure">(defrule timeline [user tweet]
     [:test/follows user author]
     [:test/tweeted author tweet])</code></pre></div><div><p>In such cases, the rule function cannot produce the result right away. The above rule's source fact is <code>:test/follows</code>:</p></div><div class="code"><pre><code class="clojure">(:source-fact (meta timeline)) =&gt; [:test/follows 2]</code></pre></div><div><p>However, from a <code>:test/follows</code> fact alone we cannot create a timeline entry. To create such an entry, we need to match it with a <code>:test/tweeted</code> fact.</p><p>To allow this, functions that represent rules that depend on more than one fact have <strong>continuations</strong>.</p><p>Continuations are functions, provided as metadata on the rule function.</p></div><div class="code"><pre><code class="clojure">(:continuation (meta timeline)) =&gt; fn?</code></pre></div><div><p>The continuation function itself has metadata, indicating what its source-fact is.</p></div><div class="code"><pre><code class="clojure">(-&gt; timeline meta :continuation meta :source-fact) =&gt; [:test/tweeted 2]</code></pre></div><div><p>As in the case of simple rules, in case of a join, the rule function also returns a sequence of tuples, only that this time these tuples are not results, but rather continuations. Each tuple contains the information that the continuation function needs in order to resume the rule.</p><p>For example, the <code>timeline</code> rule above will emit the information it learned from the <code>:test/follows</code> fact it encountered.</p></div><div class="code"><pre><code class="clojure">(timeline [&quot;alice&quot; &quot;bob&quot;]) ; Alice follows Bob
 =&gt; [[&quot;bob&quot; &quot;alice&quot; &quot;bob&quot;]]</code></pre></div><div><p>Notice that <code>&quot;bob&quot;</code> appears twice in the tuple.  Its second appearance is as the value for variable <code>author</code>. Its first appearance is as the <strong>key</strong> for the <code>:test/tweeted</code> fact.  We'll discuss keys in more detail below.</p><p>This tuple can be used to construct a new rule function based on the continuation.</p></div><div class="code"><pre><code class="clojure">(let [cont (-&gt; timeline meta :continuation) ; The continuation function we got as meta
     rule-func (cont [&quot;bob&quot; &quot;alice&quot; &quot;bob&quot;])] ; The new rule function
 (rule-func [&quot;bob&quot; &quot;Hi, Alice!&quot;]) ; :test/tweeted fact
 ) =&gt; [[&quot;alice&quot; &quot;Hi, Alice!&quot;]]</code></pre></div><div><p>Cloudlog tries to be true to its logic-programming nature, but since it is intended to work with large amounts of data, some restrictions need to be applied.  In our case, the main restriction is that in any fact, the first argument is considered the <strong>key</strong>, and there are some restrictions and recommendations regarding keys.  Generally, choosing the correct key has a significant impact on the performance of the application. A key must be specific enough so that all facts with the same key can be stored in memory at the same time.</p><p>When writing rules with joins, we need to make sure the key parameter for the joined fact is bound. For example, in the <code>timeline</code> rule, we chose the order of facts for a reason. <code>:test/tweeted</code> is keyed by <code>author</code>, and <code>:test/follows</code> is keyed by <code>user</code>.  If we get the <code>:test/follows</code> first, we learn about the <code>author</code> who's tweets we need to consider.  However, when we consider <code>:test/tweeted</code> first, this does not give us a clue regarding the <code>:test/follows</code> facts we need to consider for this tweet, since it does not provide value for <code>user</code>.</p><p>We provide a compile-time error in such cases.</p></div><div class="code"><pre><code class="clojure">(macroexpand `(defrule timeline [user tweet]
               [:test/tweeted author tweet]
               [:test/follows user author]))
 =&gt; (throws &quot;variables #{cloudlog.core_test/user} are unbound in the key for :test/follows&quot;)</code></pre></div><div><p>Of-course, guards are supported with joins.</p></div><div class="code"><pre><code class="clojure">(defrule foobar-range [w]
     [:test/foo x y]
     (let [z (+ x y)])
     (for [w (range z)])
     [:test/bar z w])</code></pre></div><div><p>In the above rule we take <code>x</code> and <code>y</code> from fact <code>:test/foo</code>, sum them to get <code>z</code>, and span the range <code>0..z</code>. We return <code>w</code> values for which there is a fact <code>&#91;:test/bar z w&#93;</code>.</p><p>The rule function for <code>foobar-range</code> will return a tuple based on the guards (and not based on <code>:test/bar</code>, which is to be considered afterwards).  The first element in each tuple is a key to be used against <code>:test/bar</code> (<code>z</code>), followed by the values of <code>w</code> and <code>z</code>:</p></div><div class="code"><pre><code class="clojure">(foobar-range [1 2]) =&gt; [[3 0 3] [3 1 3] [3 2 3]]</code></pre></div><div><p>If a matching <code>:test/bar</code> fact exists, a result will be produced.</p></div><div class="code"><pre><code class="clojure">(let [cont (-&gt; foobar-range meta :continuation)
     rule-func (cont [3 1 3])]
 (rule-func [3 1])) =&gt; [[1]]</code></pre></div><div><p>However, if it does not, an empty result will be produced.</p></div><div class="code"><pre><code class="clojure">(let [cont (-&gt; foobar-range meta :continuation)
     rule-func (cont [3 1 3])]
 (rule-func [4 1])) =&gt; []</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
